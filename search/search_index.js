var __index = {"config":{"lang":["en","de"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":"<pre><code>__   __          _\n\\ \\ / /_ _ _ __ (_) ___\n \\ V / _` | '_ \\| |/ __|\n  | | (_| | | | | | (__\n  |_|\\__,_|_| |_|_|\\___|\nYet another node info collector\n</code></pre> <p><code>yanic</code> is a respondd client that fetches, stores and publishes information about a Freifunk network.</p>"},{"location":"index.html#the-goals","title":"The goals:","text":"<ul> <li>Generating JSON for Meshviewer</li> <li>Storing statistics in InfluxDB or Graphite to be analyzed by Grafana</li> <li>Provide a little webserver for a standalone installation with a meshviewer</li> </ul>"},{"location":"about.html","title":"About","text":"<p>A little overview of yanic in connection with other software: </p>"},{"location":"about.html#how-respondd-works","title":"How respondd works","text":"<p>It sends the <code>gluon-neighbour-info</code> request and collects the answers.</p> <p>It will send UDP packets with multicast address <code>ff05:0:0:0:0:0:2:1001</code> and port <code>1001</code>.</p> <p>If a node does not answer, it will request with the last know address under the port <code>1001</code>.</p>"},{"location":"about.html#related-projects","title":"Related projects","text":""},{"location":"about.html#yanic-collecting-data","title":"yanic collecting data","text":"<p>VPNs (respondd for servers):</p> <ul> <li>mesh-announce from FreiFunkNord</li> <li>respondd from Sunz3r</li> </ul> <p>Nodes (respondd for nodes): gluon</p>"},{"location":"about.html#alternative-collectors-of-respondd-data","title":"Alternative collectors of respondd data:","text":"<ul> <li>Node informant written in Go</li> <li>HopGlass Server written in Node.js</li> </ul>"},{"location":"about.html#yanic-published-data","title":"yanic published data","text":"<p>Databases:</p> <ul> <li>InfluxDB SQL-like timeserial database</li> <li>Graphite RRD file Based</li> <li>and more</li> </ul> <p>Visualization from Databases: Grafana</p> <p>Output:</p> <ul> <li>meshviewer-ffrgb:<ul> <li>meshviewer</li> </ul> </li> <li>nodelist:<ul> <li>ffapi<ul> <li>freifunk-karte.de</li> </ul> </li> </ul> </li> <li>meshviewer (others):<ul> <li>unmaintained origin meshviewer branch: master (v1) and dev (v2)</li> </ul> </li> </ul>"},{"location":"running.html","title":"Running Yanic","text":"Community Meshviewer Database Visualisation (Grafana) Freifunk Bremen meshviewer from Freifunk Regensburg with a patch to show state.json grafana - with influxdb Freifunk Regensburg meshviewer from Freifunk Regensburg grafana - without yanic Freifunk Frankfurt am Main meshviewer from Freifunk Regensburg - Freifunk Hannover meshviewer from Freifunk Regensburg with 'minimal cosmetic modifications' grafana with influxdb Freifunk Hochstift meshviewer from Freifunk Regensburg - Freifunk in Mainz , Wiesbaden &amp; Umgebung meshviewer from Freifunk Regensburg grafana with influxdb Freifunk Ulzen meshviewer from Freifunk Regensburg - Freifunk Gera Greiz meshviewer from Freifunk Regensburg grafana - with influxdb Freifunk Westpfalz meshviewer from Freifunk Regensburg grafana- with influxdb Freifunk Rhein-Sieg e.V. meshviewer  from Freifunk Regensburg grafana- with influxdb"},{"location":"running.html#meshviewer-collector","title":"meshviewer-collector","text":"<p>A little project starts, to collect meshviewer-ffrgb data from multiple communities.</p> <p>List of communities: https://github.com/genofire/meshviewer-collector</p> <p>Meshviewer with colleced data: multi.meshviewer.org Status: data.meshviewer.org/collector.</p>"},{"location":"dev/database.html","title":"Add new database type","text":"<p>Write a new package to implement the interface database.Connection:</p> <pre><code>type Connection interface {\n    InsertNode(node *runtime.Node)\n\n    InsertLink(*runtime.Link, time.Time)\n\n    InsertGlobals(*runtime.GlobalStats, time.Time, string)\n\n    PruneNodes(deleteAfter time.Duration)\n\n    Close()\n}\n</code></pre> <p>InsertNode is stores statistics per node</p> <p>InsertLink is stores statistics per link</p> <p>InsertGlobals is stores global statistics (by <code>site_code</code>, and \"global\" like in <code>runtime.GLOBAL_SITE</code> overall sites).</p> <p>PruneNodes is prunes historical per-node data</p> <p>Close is called during shutdown of Yanic.</p> <p>For startup, you need to bind your database type by calling <code>database.RegisterAdapter(\"typeofdatabase\",ConnectFunction)</code></p> <p>it should be in the <code>func init() {}</code> of your package.</p> <p>The typeofdatabase is used as mapping in the configuration <code>[[database.connection.typeofdatabase]]</code> the <code>map[string]interface{}</code> of the content are parsed to the ConnectFunction and on of your implemented <code>Connection</code> or a <code>error</code> is needed as result.</p> <p>Short: the function signature of ConnectFunction should be <code>func Connect(configuration interface{}) (Connection, error)</code></p> <p>At last add you import string to compile the your database as well in this all package.</p> <p>TIP: take a look in the easy database type logging.</p>"},{"location":"dev/output.html","title":"Add new output type","text":"<p>Write a new package to implement the interface output.Output:</p> <pre><code>type Output interface {\n    Save(nodes *runtime.Nodes)\n}\n</code></pre> <p>Save a pre-filtered state of the Nodes</p> <p>For startup, you need to bind your output type by calling  <code>output.RegisterAdapter(\"typeofoutput\",Register)</code></p> <p>it should be in the <code>func init() {}</code> of your package.</p> <p>The typeofoutput is used as mapping in the configuration <code>[[nodes.output.typeofoutput]]</code> the <code>map[string]interface{}</code> of the content are parsed to the Register and on of your implemented <code>Output</code> or a <code>error</code> is needed as result.</p> <p>Short: the function signature of Register should be <code>func Register(configuration map[string]interface{}) (Output, error)</code></p> <p>At last add you import string to compile the your database as well in this all package.</p>"},{"location":"docs/configuration.html","title":"Configuration","text":"<p>Here you would find a long description, maybe the description in example file are enough for you.</p> <p>The config file for Yanic written in \"Tom's Obvious, Minimal Language.\" syntax. (if you need somethink multiple times, checkout out the [[array of table]] section)</p>"},{"location":"docs/configuration.html#respondd","title":"[respondd]","text":"<p>Group for configuration of respondd request.</p> <pre><code># Send respondd request to update information\n[respondd]\nenable           = true # (1)\n# Delay startup until a multiple of the period since zero time\nsynchronize    = \"1m\" # (2)\n# how often request per multicast\ncollect_interval = \"1m\" # (3)\n\n# If you have custom respondd fields, you can ask Yanic to also collect these.\n#[[respondd.custom_field]] (4)\n#name = zip\n# You can use arbitrary GJSON expressions here, see https://github.com/tidwall/gjson\n# We expect this expression to return a string.\n#path = nodeinfo.location.zip\n\n# table of a site to save stats for (not exists for global only)\n#[respondd.sites.example] (5)\n## list of domains on this site to save stats for (empty for global only)\n#domains            = [\"city\"] (6)\n\n\n# interface that has an IP in your mesh network\n[[respondd.interfaces]] # (7)\n# name of interface on which this collector is running\nifname             = \"br-ffhb\" # (8) \n# ip address which is used for sending\n# (optional - without definition used a address of ifname - preferred link local)\nip_address        = \"fd2f:5119:f2d::5\" # (9)\n# disable sending multicast respondd request\n# (for receiving only respondd packages e.g. database respondd)\n#send_no_request   = false (10)\n# multicast address to destination of respondd\n# (optional - without definition used default ff05::2:1001)\n# Very old gluon uses \"ff02::2:1001\" as multicast, newer use ff05::2:1001. If you have old and new\n# gluon nodes on the same network, create a separate \"respondd.interfaces\" section for each mutlicast address.\n#multicast_address = \"ff02::2:1001\" (11)\n# define a port to listen\n# if not set or set to 0 the kernel will use a random free port at its own\n#port              = 10001 (12)\n</code></pre> <ol> <li> <p>Enable request and collection of data per respondd requests</p> </li> <li> <p>Delay startup until a multiple of the period since zero time</p> </li> <li> <p>How often send request per respondd.</p> <p>It will send UDP packets with multicast address <code>ff05::2:1001</code> and port <code>1001</code>. If a node does not answer after the half time, it will request with the last know address under the port <code>1001</code>.</p> </li> <li> <p>If you have custom respondd fields, you can ask Yanic to also collect these.</p> <p>It is possible to have multiple custom fields, just add this group again with new parameters (see toml [[array of table]]).</p> <p>Info</p> <p>This does not automatically include these fields in the output. The meshviewer-ffrgb output module will include them under \"custom_fields\", but other modules may simply ignore them.</p> </li> <li> <p>Tables of sites to save stats for (not exists for global only).     Here is the site ffhb.</p> <p>Example</p> <pre><code>[respondd.sites.ffhb]\ndomains = [\"city\"]\n</code></pre> </li> <li> <p>list of domains on this site to save stats for (empty for global only)</p> </li> <li> <p>Interface that has an ip address in your mesh network.</p> <p>It is possible to have multiple interfaces, just add this group again with new parameters (see toml [[array of table]]).</p> </li> <li> <p>name of interface on which this collector is running.</p> </li> <li> <p>ip address is the own address which is used for sending.     If not set or set with empty string it will take an address of ifname.     (It prefers the link local address, so at babel mesh-network it should be configurated)</p> </li> <li> <p>Disable sending multicast respondd request.     For receiving only respondd packages e.g. database respondd.</p> </li> <li> <p>Multicast address to destination of respondd.     If not set or set with empty string it will take the batman default multicast address <code>ff05::2:1001</code>     (Needed to set for legacy <code>ff02::2:1001</code>)</p> </li> <li> <p>Define a port to listen and send the respondd packages.     If not set or set to 0 the kernel will use a random free port at its own.</p> </li> </ol>"},{"location":"docs/configuration.html#webserver","title":"[webserver]","text":"<p>Yanic has a little build-in webserver, which statically serves a directory. This is useful for testing purposes or for a little standalone installation.</p> <pre><code># A little build-in webserver, which statically serves a directory.\n# This is useful for testing purposes or for a little standalone installation.\n[webserver]\nenable  = false # (1)\nbind    = \"127.0.0.1:8080\" # (2)\nwebroot = \"/var/www/html/meshviewer\" # (3)\n</code></pre> <ol> <li>Enable to start the built-in webserver of Yanic</li> <li>On which ip address and port listen the webserver</li> <li>The path to a folder, which files are published on this webserver.</li> </ol>"},{"location":"docs/configuration.html#nodes","title":"[nodes]","text":"<pre><code>[nodes]\n# Cache file\n# a json file to cache all data collected directly from respondd\nstate_path     = \"/var/lib/yanic/state.json\" # (1)\n# prune data in RAM, cache-file and output json files (i.e. nodes.json)\n# that were inactive for longer than\nprune_after    = \"7d\" # (2)\n# Export nodes and graph periodically\nsave_interval  = \"5s\" # (3)\n# Set node to offline if not seen within this period\noffline_after  = \"10m\" # (4)\n</code></pre> <ol> <li>A json file to cache all data collected directly from respondd.</li> <li>Prune data in RAM, cache-file and output json files (i.e. nodes.json) that were inactive for longer than.</li> <li>Export nodes and graph periodically.</li> <li>Set node to offline if not seen within this period.</li> </ol>"},{"location":"docs/configuration.html#nodesoutputexample","title":"[[nodes.output.example]]","text":"<p>This example block shows all option which is useable for every following output type. Every output type has his own configuration under <code>nodes.output</code>. It is possible to have multiple output for one type of output, just add this group again with new parameters (see toml [[array of table]]).</p> <pre><code>[[nodes.output.example]]\nenable = true # (1)\n\n[nodes.output.example.filter] # (2)\nno_owner  = true # if it is not set, it will publish contact information of other persons (3)\nblocklist = [\"00112233445566\", \"1337f0badead\"] # (4)\nsites = [\"ffhb\"] # (5)\ndomain_as_site = true # (6)\ndomain_append_site = true # (7)\nhas_location = true # (8)\n\n[nodes.output.example.filter.in_area] # (9)\nlatitude_min  = 34.30\nlatitude_max  = 71.85\nlongitude_min = -24.96\nlongitude_max = 39.72\n</code></pre> <ol> <li>Each output format has its own config block and needs to be enabled by adding:</li> <li>For each output format there can be set different filters</li> <li> <p>Set to false, if you want the json files to contain the owner information</p> <p>Warning</p> <p>if it is not set, it will publish contact information of other persons.</p> </li> <li> <p>List of nodeids of nodes that should be filtered out, so they won't appear in output</p> </li> <li> <p>List of site_codes of nodes that should be included in output</p> </li> <li> <p>Replace the <code>site_code</code> with the <code>domain_code</code> in this output.</p> <p>e.g. <code>site_code='ffhb',domain_code='city'</code> becomes <code>site_code='city', domain_code=''</code></p> </li> <li> <p>Append on the <code>site_code</code> the <code>domain_code</code> with a <code>.</code> in this output.</p> <p>e.g. <code>site_code='ffhb',domain_code='city'</code> becomes <code>site_code='ffhb.city', domain_code=''</code></p> </li> <li> <p>set has_location to true if you want to include only nodes that have geo-coordinates set</p> <p>(setting this to false has no sensible effect, unless you'd want to hide nodes that have coordinates)</p> </li> <li> <p>nodes outside this area are not shown on the map but are still listed as a node without coordinates</p> </li> </ol>"},{"location":"docs/configuration.html#nodesoutputgeojson","title":"[[nodes.output.geojson]]","text":"<p>The geojson output produces a geojson file which contains the location data of all monitored nodes to be used to visualize the location of the nodes. It is optimized to be used with UMap but should work with other tools as well.</p> <p>Here is a public demo provided by Freifunk Muenchen: http://u.osmfr.org/m/328494/</p> <pre><code>[[nodes.output.geojson]]\nenable   = true\npath = \"/var/www/html/meshviewer/data/nodes.geojson\" # (1)\n[nodes.output.geojson.filter]\nno_owner = false\n</code></pre> <ol> <li>The path, where to store nodes.geojson</li> </ol>"},{"location":"docs/configuration.html#nodesoutputmeshviewer-ffrgb","title":"[[nodes.output.meshviewer-ffrgb]]","text":"<p>The new json file format for the meshviewer developed in Regensburg.</p> <pre><code>[[nodes.output.meshviewer-ffrgb]]\nenable   = true\npath     = \"/var/www/html/meshviewer/data/meshviewer.json\" # (1)\n# like on every output, here some filters, for example using this block:\n[nodes.output.meshviewer-ffrgb.filter]\nno_owner = false\nblocklist = [\"00112233445566\", \"1337f0badead\"]\n\n[nodes.output.meshviewer-ffrgb.filter.in_area]\nlatitude_min = 34.30\nlatitude_max = 71.85\nlongitude_min = -24.96\nlongitude_max = 39.72\n</code></pre> <ol> <li>The path, where to store meshviewer.json</li> </ol>"},{"location":"docs/configuration.html#nodesoutputmeshviewer","title":"[[nodes.output.meshviewer]]","text":"<pre><code>[[nodes.output.meshviewer]]\nenable         = false\nversion        = 2 # (1)\nnodes_path     = \"/var/www/html/meshviewer/data/nodes.json\" # (3)\ngraph_path     = \"/var/www/html/meshviewer/data/graph.json\" # (4)\n[nodes.output.meshviewer.filter]\nno_owner = false\n</code></pre> <ol> <li> <p>The structure version of the output which should be generated (i.e. nodes.json)</p> <ul> <li>version <code>1</code> is accepted by the legacy meshviewer (which is the master branch)<ul> <li>https://github.com/ffnord/meshviewer/tree/master  </li> </ul> </li> <li>version <code>2</code> is accepted by the new version of meshviewer (which are in legacy develop branch or newer)<ul> <li>https://github.com/ffnord/meshviewer/tree/dev</li> <li>https://github.com/ffrgb/meshviewer/tree/develop</li> </ul> </li> <li>The path, where to store nodes.json (supports version 1 and two, see <code>nodes_version</code>)</li> <li>The path, where to store graph.json (only version 1)</li> </ul> </li> </ol>"},{"location":"docs/configuration.html#nodesoutputnodelist","title":"[[nodes.output.nodelist]]","text":"<p>The nodelist output is a minimal output with current state of collected data. Should be preferred to use it on the ffapi for the freifunk-karte.de</p> <pre><code>[[nodes.output.nodelist]]\nenable   = false\npath     = \"/var/www/html/meshviewer/data/nodelist.json\" # (1)\n[nodes.output.nodelist.filter]\nno_owner = false\n</code></pre> <ol> <li>The path, where to store nodelist.json</li> </ol>"},{"location":"docs/configuration.html#nodesoutputprometheus-sd","title":"[[nodes.output.prometheus-sd]]","text":"<p>The Prometheus Service Discovery (SD) output is a output with the list of addresses of the nodes to use them in later exporter by prometheus. For usage in Prometheus read there Documentation Use file-based service discovery to discover scrape targets.</p> <pre><code>[[nodes.output.prometheus-sd]]\nenable         = false\npath           = \"/var/www/html/meshviewer/data/prometheus-sd.json\" # (1)\n# ip = lates recieved ip, node_id = node id from host\ntarget_address = \"ip\" # (2)\n\n# Labels of the data (optional)\n[nodes.output.prometheus-sd.labels] # (3)\nlabelname1 = \"labelvalue 1\"\n# some useful e.g.:\nhosts   = \"ffhb\"\nservice = \"yanic\"\n</code></pre> <ol> <li>The path, where to store prometheus-sd.json</li> <li> <p>In the prometheus-sd.json the usage of which information of the node as targets (address).</p> <p>Use the <code>node_id</code> as value, to put the Node ID into the target list as address.</p> <p>Use the <code>ip</code> as value to put the last IP address into the target list from where the respondd message is recieved (maybe a link-local address).</p> <p>Default value is <code>ip</code>.</p> </li> <li> <p>You could optional set manuelle labels with inserting into a prometheus-sd.json.     Useful if you want to identify the yanic instance when you use multiple own on the same prometheus database (e.g. multisites).</p> </li> </ol>"},{"location":"docs/configuration.html#nodesoutputraw","title":"[[nodes.output.raw]]","text":"<p>This output takes the respondd response as sent by the node and includes it in a JSON document. <pre><code>[[nodes.output.raw]]\nenable   = false\npath     = \"/var/www/html/meshviewer/data/raw.json\" # (1)\n[nodes.output.raw.filter]\nno_owner = false\n</code></pre></p> <ol> <li>The path, where to store raw.json</li> </ol>"},{"location":"docs/configuration.html#nodesoutputraw-jsonl","title":"[[nodes.output.raw-jsonl]]","text":"<p>This output takes the respondd response as sent by the node and inserts it into a line-separated JSON document (JSONL). In this format, each line can be interpreted as a separate JSON element, which is useful for json streaming. The first line is a json object containing the timestamp and version of the file. This is followed by a line for each node, each containing a json object. <pre><code>[[nodes.output.raw-jsonl]]\nenable   = false\npath     = \"/var/www/html/meshviewer/data/raw.jsonl\" # (1)\n[nodes.output.raw-jsonl.filter]\nno_owner = false\n</code></pre></p> <ol> <li>The path, where to store raw.jsonl</li> </ol>"},{"location":"docs/configuration.html#database","title":"[database]","text":"<p>The database organize all database types. For all database types the is a internal job, which reset data for nodes (global statistics are still stored). (We have for privacy policy to store node data for maximum seven days.)</p> <pre><code>[database]\ndelete_after = \"7d\" # (1)\ndelete_interval = \"1h\" # (2)\n</code></pre> <ol> <li>This will send delete commands to the database to prune data which is older than:</li> <li>How often run the delete commands.</li> </ol>"},{"location":"docs/configuration.html#databaseconnectionexample","title":"[[database.connection.example]]","text":"<p>This example block shows all option which is useable for every following database type. Every database type has his own configuration under <code>database.connection</code>. It is possible to have multiple connections for one type of database, just add this group again with new parameters (see toml [[array of table]]).</p> <pre><code>[[database.connection.example]]\nenable = true # (1)\n</code></pre> <ol> <li>Each database-connection has its own config block and needs to be enabled by adding:</li> </ol>"},{"location":"docs/configuration.html#databaseconnectioninfluxdb","title":"[[database.connection.influxdb]]","text":"<p>Save collected data to InfluxDB. There are would be the following measurements: - node: store node specific data i.e. clients memory, airtime - link: store link tq between two interfaces of two different nodes - global: store global data, i.e. count of clients and nodes - firmware: store the count of nodes tagged with firmware - model: store the count of nodes tagged with hardware model - autoupdater: store the count of autoupdate branch</p> <pre><code>[[database.connection.influxdb]]\nenable   = false\naddress  = \"http://localhost:8086\" # (1)\ndatabase = \"ffhb\" # (2)\nusername = \"\" # (3)\npassword = \"\" # (4)\n# insecure_skip_verify = true (5)\n\n[database.connection.influxdb.tags] # (6)\ntagname1 = \"tagvalue 1\"\nsystem   = \"productive\"\nsite     = \"ffhb\"\n</code></pre> <ol> <li>Address to connect on InfluxDB server.</li> <li>Database on which the measurement should be stored.</li> <li>Username to authenticate on InfluxDB</li> <li>Password to authenticate on InfluxDB.</li> <li>Skip insecure verify for self-signed certificates.</li> <li> <p>You could set manuelle tags with inserting into a influxdb.</p> <p>Useful if you want to identify the yanic instance when you use multiple own on the same influxdb (e.g. multisites).</p> <p>Warning</p> <p>Tags used by Yanic would override the tags from this config (e.g. <code>nodeid</code>, <code>hostname</code>, <code>owner</code>, <code>model</code>, <code>firmware_base</code>, <code>firmware_release</code>, <code>frequency11g</code>, <code>frequency11a</code>).</p> </li> </ol>"},{"location":"docs/configuration.html#databaseconnectioninfluxdb2","title":"[[database.connection.influxdb2]]","text":"<p>Save collected data to InfluxDB2.</p> <p>There are the following measurements:</p> <ul> <li>node: store node specific data i.e. clients memory, airtime</li> <li>link: store link tq between two interfaces of two different nodes with i.e. nodeid, address, hostname</li> <li>global: store global data, i.e. count of clients and nodes</li> <li>firmware: store the count of nodes tagged with firmware</li> <li>model: store the count of nodes tagged with hardware model</li> <li>autoupdater: store the count of autoupdate branch</li> </ul> <p>Info</p> <p>A bucket has to be set in buckets and buchet_default otherwise yanic would panic.</p> <p>Warning</p> <p>yanic does NOT prune node's data (so please set up data retention in InfluxDB2 setup).</p> <p>We highly recommend to setup e.g. Data retention in your InfluxDB2 server per measurements.</p> <pre><code>[[database.connection.influxdb2]]\nenable   = false\naddress  = \"http://localhost:8086\" # (1)\ntoken = \"\" # (2)\norganization_id = \"\" # (3)\nbucket_default = \"yanic\" # (4)\n\n[database.connection.influxdb2.buckets] # (5)\n#link = \"yanic-temp\"\n#node = \"yanic-temp\"\n#dhcp = \"yanic-temp\"\nglobal = \"yanic-persistent\"\n#firmware = \"yanic-temp\"\n#model = \"yanic-temp\"\n#autoupdater = \"yanic-temp\"\n\n# Tagging of the data (optional)\n[database.connection.influxdb2.tags] # (6)\n# Tags used by Yanic would override the tags from this config\n# nodeid, hostname, owner, model, firmware_base, firmware_release,frequency11g and frequency11a are tags which are already used\n#tagname1 = \"tagvalue 1\"\n# some useful e.g.:\n#system   = \"productive\"\n#site     = \"ffhb\"\n</code></pre> <ol> <li>Address to connect to the InfluxDB2 server.</li> <li>Token to get access to InfluxDB2 server.</li> <li> <p>Set organization using the InfluxDB2 server.</p> </li> <li> <p>Bucket in which are the data stored.</p> <p>Fallback of bucket per measurement, see <code>[database.connection.influxdb2.buckets]</code></p> </li> <li> <p>Buckets per measurement.</p> <p>If no buckets are set, the default bucket <code>bucket_default</code> is used.</p> </li> <li> <p>You can set additional tags which are added to all data written into the influxdb.</p> <p>Useful if you want to identify the yanic instance when you use multiple own on the same influxdb (e.g. multisites).</p> <p>Warning</p> <p>Tags used by Yanic would override the tags from this config (e.g. <code>nodeid</code>, <code>hostname</code>, <code>owner</code>, <code>model</code>, <code>firmware_base</code>, <code>firmware_release</code>, <code>frequency11g</code>, <code>frequency11a</code>).</p> </li> </ol>"},{"location":"docs/configuration.html#databaseconnectiongraphite","title":"[[database.connection.graphite]]","text":"<p>Save collected data to a graphite database.</p> <pre><code># Graphite settings\n[database.connection.graphite]]\nenable   = false\naddress  = \"localhost:2003\" # (1)\n# Graphite is replacing every \".\" in the metric name with a slash \"/\" and uses\n# that for the file system hierarchy it generates. it is recommended to at least\n# move the metrics out of the root namespace (that would be the empty prefix).\n# If you only intend to run one community and only freifunk on your graphite node\n# then the prefix can be set to anything (including the empty string) since you\n# probably wont care much about \"polluting\" the namespace.\nprefix   = \"freifunk\" # (2)\n</code></pre> <ol> <li>Address to connect on graphite server.</li> <li>Graphite is replacing every \".\" in the metric name with a slash \"/\" and uses that for the file system hierarchy it generates.     It is recommended to at least move the metrics out of the root namespace (that would be the empty prefix).     If you only intend to run one community and only freifunk on your graphite node then the prefix can be set to anything (including the empty string) since you probably wont care much about \"polluting\" the namespace.</li> </ol>"},{"location":"docs/configuration.html#databaseconnectionrespondd","title":"[[database.connection.respondd]]","text":"<p>Forward collected respondd package to a address (e.g. to another respondd collector like a central yanic instance or hopglass)</p> <pre><code># respondd (yanic)\n# forward collected respondd package to a address\n# (e.g. to another respondd collector like a central yanic instance or hopglass)\n[[database.connection.respondd]]\nenable   = false\n# type of network to create a connection\ntype     = \"udp6\" # (1)\n# destination address to connect/send respondd package\naddress  = \"stats.bremen.freifunk.net:11001\" # (2)\n</code></pre> <ol> <li> <p>Type of network to create a connection.</p> <p>Known networks are \"tcp\", \"tcp4\" (IPv4-only), \"tcp6\" (IPv6-only), \"udp\", \"udp4\" (IPv4-only), \"udp6\" (IPv6-only), \"ip\", \"ip4\" (IPv4-only), \"ip6\" (IPv6-only), \"unix\", \"unixgram\" and \"unixpacket\".</p> </li> <li> <p>Destination address to connect/send respondd package.</p> </li> </ol>"},{"location":"docs/configuration.html#databaseconnectionlogging","title":"[[database.connection.logging]]","text":"<p>This database type is just for, debugging without a real database connection. A example for other developers for new database types.</p> <pre><code># Logging\n[[database.connection.logging]]\nenable   = false\npath     = \"/var/log/yanic.log\" # (1)\n</code></pre> <ol> <li>Path to file where to store some examples with every line.</li> </ol>"},{"location":"docs/install.html","title":"Build and Installation","text":""},{"location":"docs/install.html#go","title":"go","text":""},{"location":"docs/install.html#install","title":"Install","text":"<pre><code>cd /usr/local/\nwget https://go.dev/dl/go1.24.4.linux-amd64.tar.gz -O go-release-linux-amd64.tar.gz\ntar xvf go-release-linux-amd64.tar.gz\nrm go-release-linux-amd64.tar.gz\n</code></pre>"},{"location":"docs/install.html#configure-go","title":"Configure go","text":"<p>Add these lines in your root shell startup file (e.g. <code>/root/.bashrc</code>): <pre><code>export GOPATH=/opt/go\nexport PATH=$PATH:/usr/local/go/bin:$GOPATH/bin\n</code></pre></p>"},{"location":"docs/install.html#yanic","title":"Yanic","text":""},{"location":"docs/install.html#compile","title":"Compile","text":"<p>As root: <pre><code>go install github.com/FreifunkBremen/yanic@latest\n</code></pre></p> <p>or to install a different checkout for example for development run:</p> <pre><code>git clone https://github.com/FreifunkBremen/yanic\ncd yanic\ngo install .\n</code></pre>"},{"location":"docs/install.html#install_1","title":"Install","text":"<pre><code>cp /opt/go/src/github.com/FreifunkBremen/yanic/contrib/init/linux-systemd/yanic.service /lib/systemd/system/yanic.service\nsystemctl daemon-reload\n</code></pre> <p>Before start, you should configure yanic by the file <code>/etc/yanic.conf</code>: <pre><code>systemctl start yanic\n</code></pre></p> <p>Enable to start on boot: <pre><code>systemctl enable yanic\n</code></pre></p>"},{"location":"docs/install.html#update","title":"Update","text":"<p>For an update just stop yanic and then call the same <code>go</code> command again (again as root): <pre><code>systemctl stop yanic\ngo get -v -u github.com/FreifunkBremen/yanic\n</code></pre> Then update the config file, for example look at the diff with the new example: <pre><code>diff /opt/go/src/github.com/FreifunkBremen/yanic/config_example.toml /etc/yanic.conf\n</code></pre></p>"},{"location":"docs/quick_conf.html","title":"Quick Configuration","text":"<pre><code>cp /opt/go/src/github.com/FreifunkBremen/yanic/config_example.toml /etc/yanic.conf\n</code></pre>"},{"location":"docs/quick_conf.html#configuration","title":"Configuration","text":"<p>For an easy startup you only need to edit the <code>[[respondd.interfaces]]</code> in section <code>[respondd]</code> in file <code>/etc/yanic.conf</code>.  </p> <p>Then create the following files and folders: <pre><code>adduser --system yanic --home /var/lib/yanic\nmkdir -p /var/lib/yanic\nmkdir -p /var/www/html/meshviewer/data\ntouch /var/log/yanic.log\nchown yanic /var/log/yanic.log /var/lib/yanic /var/www/html/meshviewer/data\n</code></pre></p>"},{"location":"docs/quick_conf.html#standalone","title":"Standalone","text":"<p>If you like to run a standalone meshviewer, just set <code>enable</code> in section <code>[webserver]</code> to <code>true</code>.</p>"},{"location":"docs/quick_conf.html#configure-the-meshviewer","title":"Configure the meshviewer:","text":"<p>set <code>dataPath</code> in <code>config.json</code> to <code>/data/</code> and make the <code>build</code> directory accessible under <code>/var/www/html/meshviewer</code>.</p>"},{"location":"docs/quick_conf.html#with-webserver-apache-nginx","title":"With webserver (Apache, nginx)","text":"<p>The meshviewer needs the output files like <code>nodes_path</code> and <code>graph_path</code> inside the same directory as the <code>dataPath</code>. Change the path in the section <code>[meshviewer]</code> accordingly.</p>"},{"location":"docs/usage.html","title":"Usage","text":"<p>Yanic provides several commands:</p> <ul> <li><code>import</code></li> <li><code>query</code></li> <li><code>serve</code></li> </ul>"},{"location":"docs/usage.html#import","title":"Import","text":""},{"location":"docs/usage.html#rrd-file","title":"RRD-File","text":"<p>Warning, just tested with olddata.rrd from Freifunk Bremen generated by detailed-rrds branch of ffmap-backend</p> <pre><code>Usage:\n  yanic import &lt;file.rrd&gt; [flags]\n\nExamples:\n  yanic import --config /etc/yanic.toml olddata.rrd\n\nFlags:\n  -c, --config string   Path to configuration file (default \"config.toml\")\n  -h, --help            help for import\n</code></pre>"},{"location":"docs/usage.html#firstseen","title":"Firstseen","text":"<p>To import firstseen values there is a little script in contrib:</p> <pre><code>/opt/go/src/github.com/FreifunkBremen/yanic/contrib/yanic-import-timestamp -n path/to/nodes_old.json -s state.json /var/lib/yanic/state.json\n</code></pre> <p>On a productive system @ once:</p> <pre><code>systemctl stop yanic; cp /var/lib/yanic/state.json /var/lib/yanic/state.bak; /opt/go/src/github.com/FreifunkBremen/yanic/contrib/yanic-import-timestamp -n path/to/nodes_old.json -s /var/lib/yanic/state.json; systemctl start yanic;\n</code></pre>"},{"location":"docs/usage.html#serve","title":"Serve","text":"<p>runs yanic in collector-modus to genereate files (e.g. for meshviewer) and save values in databases</p> <p>from shell</p> <pre><code>Usage:\n  yanic serve [flags]\n\nExamples:\n  yanic serve --config /etc/yanic.toml\n\nFlags:\n  -c, --config string   Path to configuration file (default \"config.toml\")\n  -h, --help            help for serve\n</code></pre> <p>or run as daemon</p>"},{"location":"docs/usage.html#query","title":"Query","text":"<p>Send a single request and show response like <code>gluon-neighbour-info</code> on gluon.</p> <p>e.g.  to check the right interface</p> <pre><code>Usage:\n  yanic query &lt;interface&gt; &lt;destination&gt; [flags]\n\nExamples:\n  yanic query wlan0 \"fe80::eade:27ff:dead:beef\"\n\nFlags:\n  -h, --help       help for query\n      --wait int   Seconds to wait for a response (default 1)\n</code></pre>"}]}